#include <iostream>
#include <opencv2/opencv.hpp>
#include "opencv2/highgui.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"

using namespace std;
using namespace cv;

Mat src, src_color, dst, dst_filtering, dst_morph, dst_morph1, dst_morph2;

int element_shape = MORPH_RECT;		
Mat element = getStructuringElement(element_shape, Size(30, 30));

int element_shape1 = MORPH_RECT;
Mat element1 = getStructuringElement(element_shape1, Size(50, 50));

int element_shape2 = MORPH_RECT;
Mat element2 = getStructuringElement(element_shape2, Size(10, 10));

int const max_value = 255;
int const max_type_threshhold = 16;

int kernel_size = 11;

int threshold_value = 192;
int threshold_type = 16; 
//0: Binary, 1: Binary Inverted, 2 : Threshold Truncated, 3 : Threshold to Zero
//4 : Threshold to Zero Inverted, 8 : Threshold OTSU, 16 : Threshold Triangle


int main(int argc, char* argv[]) {

    //read origin sorce image
    src_color = imread("Lab_GrayScale_TestImage.jpg");

    //read gray scale sorce image
	src = imread("Lab_GrayScale_TestImage.jpg", 0);     
	
	if (src.empty())
	{
		cout << "File Read Failed : src is empty" << endl;
        cv::waitKey(0);
	}
    
    //Load gray scale IMG
    //cv::namedWindow("SORCE IMG", WINDOW_NORMAL);
	//if (!src.empty()) cv::imshow("SORCE IMG", src);

    //Load threshold IMG 
    cv::threshold(src, dst, threshold_value, max_value, threshold_type);
    //cv::namedWindow("ThreshWIndow", WINDOW_NORMAL);
    //cv::imshow("ThreshWIndow", dst);

    //Load medianblured IMG
    cv::medianBlur(dst, dst_filtering, kernel_size);
    //cv::namedWindow("Filtering", WINDOW_NORMAL);
    //cv::imshow("Filtering", dst_filtering);

    //Load Morphology IMG
    cv::dilate(dst_filtering, dst_morph, element);
    cv::erode(dst_morph, dst_morph1, element1);
    cv::dilate(dst_morph1, dst_morph2, element2);
    //cv::namedWindow("Morphology", WINDOW_NORMAL);
    //cv::imshow("Morphology", dst_morph2);
   
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;

    //Recognize the boundary line of the object
    cv::findContours(dst_morph2, contours, cv::RETR_LIST, cv::CHAIN_APPROX_SIMPLE, Point(0, 0)); //RETR_EXTERNAL->RETR_LIST 
    
    /// Draw all contours excluding holes
    Mat drawing(dst_morph2.size(), CV_8U, cv::Scalar(0));
    cv::drawContours(drawing, contours, -1, cv::Scalar(255), 3);
    cout << " Number of coins are =" << contours.size() << endl;

    int a = 0, b = 0, c = 0;
    int yellowCount = 0;
    int redCount = 0;
    int blueCount = 0;
    int turquoiseCount = 0;
    int greenCount = 0;

    //Drawing the each color line and counting the numbers of the object 
    for (int i = 0; i < contours.size(); i++){ 
        std::cout << " * Contour[" << i << "] -  Area OpenCV: " << cv::contourArea(contours[i]) << " - Length: " << cv::arcLength(contours[i], true) << std::endl;
        
        if (cv::contourArea(contours[i]) <= 2300.00) a = 0, b = 255, c = 255, yellowCount++; //yellow

        else if (cv::contourArea(contours[i]) > 2300.00 && cv::contourArea(contours[i]) < 3000.00) a = 0, b = 0, c = 255, redCount++; //red

        else if (cv::contourArea(contours[i]) > 3000.00 && cv::contourArea(contours[i]) < 3660.00) a = 255, b = 0, c = 0, blueCount++;//blue
        
        else if (cv::contourArea(contours[i]) > 3660.00 && cv::contourArea(contours[i]) < 4000.00) a = 255, b = 255, c = 0, turquoiseCount++;//turquiose

        else if (cv::contourArea(contours[i]) > 4000.00) a = 0, b = 255, c = 0, greenCount++; //green
    
        cv::Rect rect = cv::boundingRect(contours[i]);

        double scalingFactor = 1.3; // Variables that control rectangular size
        rect.x -= rect.width * (scalingFactor - 1) / 2;
        rect.y -= rect.height * (scalingFactor - 1) / 2;
        rect.width *= scalingFactor;
        rect.height *= scalingFactor;

        cv::rectangle(src_color, rect, cv::Scalar(a, b, c), 3);

        std::string label = std::to_string(i); // Change the numbers to the letters
        cv::putText(src_color, label, cv::Point(rect.x, rect.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(0, 0, 255), 2);

        a = 0, b = 0, c = 0;
    }

    //Output of drawing rectangular on the origin sorce image 
    cv::namedWindow("Contour", WINDOW_NORMAL);
    cv::imshow("Contour", src_color);

    //Output of counting the numbers of the Nuts and Bolts
    std::cout << "M5 Bolt= " << blueCount << std::endl;
    std::cout << "M6 Bolt= " << greenCount << std::endl;
    std::cout << "M5 Hex Nut= " << yellowCount << std::endl;
    std::cout << "M6 Hex Nut= " << turquoiseCount << std::endl;
    std::cout << "M5 Rect Nut= " << redCount << std::endl;
  
    //Load histogram IMG
    int histSize = 256;
    float range[] = { 0, 255 }; 
    const float* histRange = { range };
    bool uniform = true, accumulate = false;

    Mat hist1D;
    cv::calcHist(&src, 1, 0, Mat(), hist1D, 1, &histSize, &histRange, uniform, accumulate);
    
    int hist_w = 512, hist_h = 400;
    int bin_w = cvRound((double)hist_w / histSize);

    Mat histImage1D(hist_h, hist_w, CV_8UC1, Scalar(255));
    cv::normalize(hist1D, hist1D, 0, histImage1D.rows, cv::NORM_MINMAX, -1, Mat());

    for (int i = 1; i < histSize; i++)
    {
        cv::line(histImage1D, Point(bin_w * (i - 1), hist_h - cvRound(hist1D.at<float>(i - 1))),
            Point(bin_w * (i), hist_h - cvRound(hist1D.at<float>(i))),
            Scalar(0, 0, 0), 2, 8, 0);
    }

    //cv:: imshow("calcHist Demo", histImage1D);
    
    cv::waitKey(0);
   
    return EXIT_SUCCESS;
}
